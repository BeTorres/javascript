#!/usr/bin/env node

/**
 * This nodejs executable reads in the top-level package.json, babel.config.js
 * and the special .eslintrc.track.json and copies them to each exercise.
 *
 * Preserves the package.json version number in order to allow for versioned
 * track package.json
 */

/* eslint-disable no-console, no-restricted-syntax */

// @ts-check

const fs = require('fs')
const path = require('path')

const { ENOENT } = require('constants')

const ROOT_DIR = path.join(__dirname, '..', '..')
const EXERCISES_PATH = path.join(ROOT_DIR, 'exercises')
const PACKAGE_PATH = path.join(ROOT_DIR, 'package.json')
const BABEL_CONFIG_PATH = path.join(ROOT_DIR, 'babel.config.js')
const ESLINTRC_TRACK_PATH = path.join(ROOT_DIR, '.eslintrc.track.json')

const PACKAGE_KEEP = ['version']
const PACKAGE_SCRIPTS_ONLY = ['test', 'watch', 'lint', 'lint-test']

/**
 * When a copy completes, this prints any error
 * @param {NodeJS.ErrnoException | undefined} err
 */
function onCopyComplete(err) {
  if (!err) {
    return
  }

  console.error(err)
  // don't exit, just ignore
}

fs.readFile(PACKAGE_PATH, (packageSourceErr, packageSource) => {
  if (packageSourceErr) {
    console.error(packageSourceErr)
    process.exit(1)
  }

  // This is the base package
  const basePackage = JSON.parse(packageSource.toString())

  const packageConfigName = path.basename(PACKAGE_PATH)
  const babelConfigName = path.basename(BABEL_CONFIG_PATH)
  const eslintConfigName = path.basename(ESLINTRC_TRACK_PATH).replace('.track', '')

  console.log(`=> package config name: ${packageConfigName}`)
  console.log(`=> babel config name: ${babelConfigName}`)
  console.log(`=> eslint config name: ${eslintConfigName}`)

  fs.readdir(EXERCISES_PATH, (directoryErr, directories) => {
    if (directoryErr) {
      console.error(directoryErr)
      process.exit(2)
    }

    const lastArg = process.argv[process.argv.length - 1]
    const SPECIFIC_EXERCISE = process.argv.length > 2 && !lastArg.startsWith('-')
      ? lastArg
      : false

    if (SPECIFIC_EXERCISE) {
      console.log(`=> only ${SPECIFIC_EXERCISE}`)
    }

    for (const directory of directories) {
      if (SPECIFIC_EXERCISE && directory !== SPECIFIC_EXERCISE) {
        // eslint-disable-next-line no-continue
        continue
      }

      console.log(`=> sync: ${directory}`)

      const excersizePath = path.join(EXERCISES_PATH, directory)

      const excersizeBabelConfigPath = path.join(excersizePath, babelConfigName)
      const excerciseEslintConfigPath = path.join(excersizePath, eslintConfigName)
      const excerciseConfigPath = path.join(excersizePath, packageConfigName)

      fs.copyFile(BABEL_CONFIG_PATH, excersizeBabelConfigPath, onCopyComplete)
      fs.copyFile(ESLINTRC_TRACK_PATH, excerciseEslintConfigPath, onCopyComplete)

      fs.readFile(excerciseConfigPath, (err, currentPackageSource) => {
        if (err && err.errno !== ENOENT) {
          onCopyComplete(err)
          return
        }

        const currentPackage = err ? { ...basePackage, version: '1.0.0' } : JSON.parse(currentPackageSource.toString())

        // Make sure the new package.json retains these fields
        const newPackage = { ...basePackage }
        for (const keep of PACKAGE_KEEP) {
          newPackage[keep] = currentPackage[keep]
        }

        // Make sure the new package.json only has the listed scripts
        newPackage.scripts = {}
        for (const script of PACKAGE_SCRIPTS_ONLY) {
          newPackage.scripts[script] = basePackage.scripts[script]
        }

        fs.writeFile(excerciseConfigPath, JSON.stringify(newPackage, null, 2), onCopyComplete)
      })
    }
  })
})
